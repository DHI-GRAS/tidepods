# -*- coding: utf-8 -*-
"""
Created on March 13 2022

@autor: ansu
"""
import pathlib
import xml.etree.ElementTree as ET
import numpy as np
from affine import Affine
from shapely.geometry import box, Point, shape, mapping
import fiona
from fiona.crs import from_epsg
import datetime
import os
import subprocess
import rasterio
from rasterio import features
import shutil
import matplotlib
import matplotlib.pyplot as plt
from rasterio.io import MemoryFile
from rasterio.transform import Affine
import rasterio.warp
import rasterio.mask
from datetime import datetime as dt
import mikeio
from mikeio import Dfs0, Dataset



def read_meta(infile):
    """
    Read metadata xml file of Sentinel 2 tile.

    Parameters
    ----------
    metafile : Path or str
        Path to the MTD_TL.xml file in the S2 Granule/Product subdir of the .SAFE.

    Returns
    -------
    meta : Dictionary
        Dictionary of relevant metadata used to create the tide surface.

    """
    meta = {}
    
    dataset = rasterio.open(infile)
    meta["ncols"], meta["nrows"] = dataset.shape
    meta["epsg"] = dataset.crs
   
    transform = dataset.transform
    meta["ulx"] = float(transform[2])
    meta["uly"] = float(transform[5])
    meta["xdim"] = float(transform[0])
    meta["ydim"] = float(transform[4])    
    
    return meta


def make_profile(meta):
    """
    Create a rasterio profile based on the metadata file provided.

    Parameters
    ----------
    meta : Dictionary
        Dictionary of metadata information as returned by read_meta().

    Returns
    -------
    profile : Dictionary
        Rasterio profile.

    """

    
    profile = {
        "driver": "GTiff",
        "dtype": "float32",
        "nodata": None,
        "width": meta["nrows"],
        "height": meta["ncols"],
        "count": 1,
        "crs": meta["epsg"],
        "transform": Affine(
            meta["xdim"], 0.0, meta["ulx"], 0.0, meta["ydim"], meta["uly"]
        ),
    }

    return profile


def make_ds_array(profile):
    """
    Create an empty numpy array of the needed shape as per the profile.

    Parameters
    ----------
    profile : Dictionary
        The rasterio profile created by make_profile().

    Returns
    -------
    ds : Array
        Empty numpy array.

    """
    ds = np.empty(
        [int(profile["width"]), int(profile["height"])], dtype=profile["dtype"]
    )
    ds = ds[np.newaxis, :, :]

    return ds


def get_dataset_outline(dataset, profile, target_epsg=4326, buffer= 0.25):
    """
    Get the outline of the input raster dataset, reporject and buffer if wanted.

    Parameters
    ----------
    dataset : Array
        Numpy array as created by make_ds_array().
    profile : Dictionary
        The rasterio profile created by make_profile()..
    target_epsg : Integer, optional
        The target EPSG code. The default is 4326.
    buffer : Float, optional
        The wanted buffer to be added to the shape. The value should be
        consistent with the given EPSG. i.e. give buffer size in degrees for
        EPSG 4326. The default is 0.125.

    Returns
    -------
    shp : Shapely object
        Input dataset AOI bounds as a shapely polygon object.

    """
    with MemoryFile() as memfile:
        with memfile.open(**profile) as ds:
            ds.write(dataset)

    left, bottom, right, top = ds.bounds
    in_crs = ds.crs

    if target_epsg is None:
        shp = box(left, bottom, right, top)

    else:
        out_crs = rasterio.crs.CRS.from_epsg(target_epsg)
        minx, miny, maxx, maxy = rasterio.warp.transform_bounds(
            in_crs, out_crs, left, bottom, right, top
        )
        shp = box(minx, miny, maxx, maxy)

    if buffer:
        shp = shp.buffer(buffer, join_style=2)

    return shp


def create_pts(shp, spacing):
    """Generate fixed distance points within a polygon.

    Parameters
    ----------
    infile : str
        Path to polygon or raster AOI.

    Returns
    -------
    plist : list
        List of shapely points for points within infile.

    Raises
    ------
    ValueError
        If plist is empty as no points have been generated.

    """
    bounds = shp.bounds
    minx, miny, maxx, maxy = bounds
    plist = []
    offset = spacing / 2
    for x in np.arange(minx + offset, maxx - offset, spacing):
        for y in np.arange(miny + offset, maxy - offset, spacing):
            p = Point(x, y)
            if p.within(shp):
                plist.append(p)

    if not plist:
        raise ValueError(
            "No points generated. Is the input file covering a large enough AOI?"
        )

    return plist


def generate_pfs(pts, meta, mikepath, tempdir, date):
    """Generate a pfs file using DHI.PFS.

    Parameters
    ----------
    pts : list
        List of shapely points generated by create_pts().
    meta : dictionary
        Metadata dictionary created by read_meta().
    mikepath : pathlib Path
        Path to MIKE installation directory.
    tempdir : str
        Path to the temporary working directory.

    Raises
    ------
    ValueError
        If DHI.PFS could not be imported or is not found in the mike folder.
    ValueError
        If the PFS file could not be created.

    """

    temppfs = os.path.join(tempdir, "temp.pfs")

    dhi_pfs_path = list(mikepath.glob("**/Mike SDK/**/*DHI.PFS.dll"))[0]

    constituents_path = list(
        mikepath.glob("**/global_tide_constituents_height_0.125deg.dfs2")
    )[0]
    prepack_path = list(mikepath.glob("**/Tide_Constituents/prepack.dat"))[0]

    import clr
    import System

    try:
        clr.AddReference(str(dhi_pfs_path))
        import DHI.PFS

    except (ImportError, System.IO.FileNotFoundException) as exception:
        msg = f'DHI.PFS not found. Is the path correct: "{dhi_pfs_path}"?'
        raise ValueError(msg) from exception

    # Begin PFS Generation Parameters using DHI.PFS.PFSBuilder

    pfsbuilder = DHI.PFS.PFSBuilder()

    pfsbuilder.AddTarget("TidePredictor")  # First Section

    pfsbuilder.AddKeyword("Name")
    #pfsbuilder.AddString(str(meta["tile_id"]))
    pfsbuilder.AddKeyword("constituent_file_name")
    pfsbuilder.AddString(str(constituents_path))

    pfsbuilder.AddKeyword("prepack_file_name")
    pfsbuilder.AddString(str(prepack_path))

    pfsbuilder.AddKeyword("start_date")
    DHI.PFS.PFSExtensions.AddDate(pfsbuilder, System.DateTime(date.year-1, date.month, date.day))
    pfsbuilder.AddKeyword("end_date")
    DHI.PFS.PFSExtensions.AddDate(pfsbuilder, System.DateTime(date.year, date.month, date.day))
    pfsbuilder.AddKeyword("timestep")
    pfsbuilder.AddDouble(24)

    pfsbuilder.AddKeyword("number_of_files")
    pfsbuilder.AddInt(1)

    pfsbuilder.AddKeyword("ShowGeographic")
    pfsbuilder.AddInt(1)

    pfsbuilder.AddSection("File_1")  # File Section
    pfsbuilder.AddKeyword("format")
    pfsbuilder.AddInt(0)
    pfsbuilder.AddKeyword("file_name")
    pfsbuilder.AddFileName("temp.dfs0")
    pfsbuilder.AddKeyword("description")
    pfsbuilder.AddString("Predicted Tide Level")
    pfsbuilder.AddKeyword("number_of_points")
    pfsbuilder.AddInt(len(pts))

    # Points section enumerated for each point generated within shapefile

    for pid, p in enumerate(pts, 1):
        pfsbuilder.AddSection("Point_" + str(pid))
        pfsbuilder.AddKeyword("description")
        pfsbuilder.AddInt(pid)
        pfsbuilder.AddKeyword("y")
        pfsbuilder.AddDouble(p.coords[0][1])
        pfsbuilder.AddKeyword("x")
        pfsbuilder.AddDouble(p.coords[0][0])
        pfsbuilder.EndSection()

    pfsbuilder.EndSection()
    pfsbuilder.EndSection()
    pfsbuilder.Write(temppfs)

    if not os.path.exists(temppfs):
        raise ValueError("PFS file not created. Recheck creation options.")
        
  

def make_dfs0(mikepath, pfsfile):

    """Generate a dfs0 file from the input PFS in the same directory.

    Parameters
    ----------
    mikepath : str
        Path to MIKE installation directory.
    pfsfile : str
        Path to PFS file.

    Raises
    ------
    ValueError
        If the DFS file could not be created.
    """
    tp = str(list(mikepath.glob("**/TidePredictor.exe"))[0])
    cmd = [tp, pfsfile]
    
    try:
        subprocess.check_call(cmd, shell=True)
    except subprocess.CalledProcessError as e:
        raise RuntimeError(
            "command '{}' return with error (code {}): {}".format(
                e.cmd, e.returncode, e.output
            )
        )
    dfsfile = pfsfile.replace(".pfs", ".dfs0")

    if not os.path.exists(dfsfile):
        raise ValueError(
            f"DFS file not created. Please check that you are connected to the VPN and that the path to the tide predictor is correct: {tp}."
        )


def tide_values_from_dfs0(mikepath, meta, dfsfilepath, date, df):
    """Read and extract values from dfs0 file using DHI.Generic.MikeZero.DFS.

    Parameters
    ----------
    mikepath : str
        Path to MIKE installation directory.
    meta : dictionary
        Metadata dictionary created by read_meta().
    dfsfilepath : str
        Path to the dfs file created by make_dfs0().

    Returns
    -------
    tide_values : list
        List of tide values for image acquisiton date and time.

    Raises
    ------


    ValueError
        If DHI.Generic could not be imported or is not found in the sdkpath folder.
    ValueError
        If no tide values could be generated.

    """


    import clr

    clr.AddReference("System")
    import System

    generic_mike_zero_path = list(
        mikepath.glob("**/Mike SDK/**/*DHI.Generic.MikeZero.DFS.dll")
    )[0]
    try:
        clr.AddReference(str(generic_mike_zero_path))
        import DHI.Generic.MikeZero.DFS

    except (ImportError, System.IO.FileNotFoundException) as exception:
        msg = f'DHI.Generic not found. Is the path to the mike installation directory correct: "{mikepath}"?'
        raise ValueError(msg) from exception

    #dfs_img_datetime = datetime.datetime.strptime(
    #    meta["sensing_time"], "%Y-%m-%dT%H:%M:%S"
    #)
          
    dfs_img_datetime = date
    dfsfile = DHI.Generic.MikeZero.DFS.DfsFileFactory.DfsGenericOpen(dfsfilepath)    
  
    # read timestep in seconds, convert to minutes
    timestep = int(dfsfile.FileInfo.TimeAxis.TimeStep)
    sdt = dfsfile.FileInfo.TimeAxis.StartDateTime

    dfs_start_datetime = datetime.datetime(
        *(getattr(sdt, n) for n in ["Year", "Month", "Day", "Hour", "Minute", "Second"]))

    print("dfs_start_datetime", dfs_start_datetime)
    print("dfs_img_datetime", dfs_img_datetime)

    diff = dfs_img_datetime - dfs_start_datetime

    
    tide_values_lat = []
    tide_values_hat = []
    for i in range(len(dfsfile.ItemInfo)):
        min_value = float(dfsfile.ItemInfo[i].MinValue)
        max_value = float(dfsfile.ItemInfo[i].MaxValue)
        tide_values_lat.append(min_value)
        tide_values_hat.append(max_value) 

    tide_values_msl = []   
    for (columnName, columnData) in df.iteritems():
        msl_value = columnData.mean()
        tide_values_msl.append(msl_value) 

    dfsfile.Dispose()

    return tide_values_msl, tide_values_lat, tide_values_hat, 


def write_tide_values(tv_MSL,tv_LAT,tv_HAT, plist, outfile, outfolder):
    """Write generated points and tide values to a new shapefile.

    Parameters
    ----------
    tide_values : list
        List of tide values generated by tide_values_from_dfs0().
    plist : list
        List of shapely points generated by create_pts()

    Returns
    -------
    ms : Fiona collection
        Points

    """
    pts_schema = {
        "geometry": "Point",
        "properties": {"p_ID": "int", "MSL": "float",
                       "LAT": "float", "HAT": "float"}}
    mem_file = fiona.MemoryFile()
    ms = mem_file.open(crs=from_epsg(4326), driver="ESRI Shapefile", schema=pts_schema)
    out_name_points = outfile.split('\\')[-1][:-4]+'.shp'


    for pid, (p, tv_MSLL,tv_LATT,tv_HATT) in enumerate(zip(plist, tv_MSL,tv_LAT,tv_HAT)):
        prop = {"p_ID": int(pid + 1), "MSL": float(tv_MSLL),
              "LAT": float(tv_LATT), "HAT": float(tv_HATT)}
        ms.write({"geometry": mapping(p), "properties": prop})
    
    
    with fiona.open(outfile, 'w', crs=from_epsg(4326), driver='ESRI Shapefile',
                    schema=pts_schema) as output:
        for pid, (p, tv_MSL,tv_LAT,tv_HAT) in enumerate(zip(plist, tv_MSL,tv_LAT,tv_HAT)):
            prop = {"p_ID": int(pid + 1), "MSL": float(tv_MSL),"LAT": float(tv_LAT), "HAT": float(tv_HAT)}
            output.write({"geometry": mapping(p), "properties": prop})
    
    return ms

def rasterize_points(pc, shp):
    """
    Rasterize the created points

    Parameters
    ----------
    pc : Fiona collection
        Points collection as created by write_tide_values().
    shp : Shapely shape
        Shapely polygon as created by get_dataset_outline().

    Returns
    -------
    image : array
        Image array.
    profile : dictionary
        Dictionary of the updated profile.

    """
    pc.mode = "r"  # set collection mode to read


    # transform for the target raster, hardcoded 0.125 deg resoution as

    tr = rasterio.transform.from_origin(shp.bounds[0], shp.bounds[-1], 0.125, 0.125)

    minx, miny, maxx, maxy = shp.bounds
    xsize = int((maxx - minx) / 0.125)
    ysize = int((maxy - miny) / 0.125)

    profile = {
        "driver": "GTiff",
        "dtype": "float32",
        "nodata": None,
        "width": xsize,
        "height": ysize,
        "count": 1,
        "crs": "EPSG:4326",
        "transform": tr,
    }

    image_MSL = features.rasterize(((p["geometry"], p["properties"][[*pc.schema["properties"].keys()][1]])
            for p in pc), out_shape=(xsize, ysize),transform=tr)
    image_MSL = image_MSL[np.newaxis, :, :]


    image_LAT = features.rasterize(((p["geometry"], p["properties"][[*pc.schema["properties"].keys()][2]])
            for p in pc), out_shape=(xsize, ysize),transform=tr)
    image_LAT = image_LAT[np.newaxis, :, :]


 
    image_HAT = features.rasterize(((p["geometry"], p["properties"][[*pc.schema["properties"].keys()][3]])
            for p in pc), out_shape=(xsize, ysize),transform=tr)
    image_HAT = image_HAT[np.newaxis, :, :]

    return image_MSL, image_LAT, image_HAT, profile



def write_raster(src_array, src_profile, dst_array, dst_profile, outfile):
    """
    Write the final masked or unmasked raster to file.

    Parameters
    ----------
    src_array : Array
        The reprojected image array created by rasterize_points().
    src_profile : Dictionary
        The profile dictionary of the reprojected array.
    dst_array : Array
        The array created by make_ds_array().
    dst_profile : Dictionary
        The profile dictionary for the dst_array.
    outfile : String
        Path to output file.

    Returns
    -------
    None.

    """

    dst_image = rasterio.warp.reproject(
        src_array,
        dst_array,
        src_transform=src_profile["transform"],
        src_crs=src_profile["crs"],
        src_nodata=None,
        dst_transform=dst_profile["transform"],
        dst_crs=dst_profile["crs"],
        dst_nodata=None,
        resampling=1,
    )[0]

    with rasterio.open(outfile, "w", **dst_profile) as dst:
        dst.write(dst_image)

def main(infile, outfolder = None, date=None, timestamp=None):

    """
    Run main function to run the timeseries command.

    Parameters
    ----------
    infile : String
        Path to the vht image file.
    outfolder : String
        Path to the output folder. This will be created if it does not exist.
    land_mask : String, optional
        Path to the land mask to be applied. The default is None.

    Returns
    -------
    None.
    """

  
    if outfolder is None:
        outfolder = pathlib.Path(infile).parent
    else:
        outfolder = outfolder  
   
    meta = read_meta(infile)

    if date is None and timestamp is None:
        imdfile = list(pathlib.Path(infile).parent.glob("*.imd"))[0]
        indate  = "20"+imdfile.name[0:13]
        date = datetime.datetime.strptime(indate, "%Y%b%d%H%M%S")
        print("\nDate is taken from the .imd file:", date)    
    else:
        indate = date
        date = datetime.datetime.combine(date, timestamp)
        print("\nDate:", date,"\n") 

    if not os.path.isdir(outfolder):
        os.makedirs(outfolder)
     
    
    mikepath = os.environ['MIKE'] = "C:\Program Files (x86)\DHI"
    #ikepath = os.environ.get['MIKE']
    mikepath = pathlib.Path(mikepath)
    
    dst_profile = make_profile(meta)
    dst_array = make_ds_array(dst_profile)
    
    shp = get_dataset_outline(dst_array, dst_profile)
    pts = create_pts(shp, 0.125)

    tempfolder = os.path.join(outfolder, "temp")
    os.makedirs(tempfolder, exist_ok=True)
    generate_pfs(pts, meta, mikepath, tempfolder, date)

    temp_pfs_path = str(list(pathlib.Path(tempfolder).glob("*.pfs"))[0])
    make_dfs0(mikepath, temp_pfs_path)
    temp_dfs0_path = str(list(pathlib.Path(tempfolder).glob("*.dfs0"))[0])


    dfs = Dfs0(temp_dfs0_path)
    df = dfs.to_dataframe()
    utfilename_csv = ".".join(["tides",str(indate), "csv"])
    outfile_csv = os.path.join(outfolder, utfilename_csv)
    df.to_csv(outfile_csv)


    tv_MSL,tv_LAT,tv_HAT = tide_values_from_dfs0(mikepath, meta, temp_dfs0_path, date, df)

    outfilename_shp = ".".join(["tides",str(indate), "shp"])
    outfile_shp = os.path.join(outfolder, outfilename_shp)
    
    c = write_tide_values(tv_MSL,tv_LAT,tv_HAT, pts, outfile_shp, outfolder)

    image_MSL, image_LAT, image_HAT, src_profile = rasterize_points(c, shp)

    utfilename_tif_MSL = ".".join(["tides",str(indate), "MSL", "tif"])
    outfile_tif_MSL = os.path.join(outfolder, utfilename_tif_MSL)
    write_raster(image_MSL, src_profile, dst_array, dst_profile, outfile_tif_MSL)

    outfilename_tif_HAT = ".".join(["tides",str(indate), "HAT", "tif"])
    outfile_tif_HAT = os.path.join(outfolder, outfilename_tif_HAT)
    write_raster(image_HAT, src_profile, dst_array, dst_profile, outfile_tif_HAT)


    outfilename_tif_LAT = ".".join(["tides",str(indate), "LAT", "tif"])
    outfile_tif_LAT = os.path.join(outfolder, outfilename_tif_LAT)
    write_raster(image_LAT, src_profile, dst_array, dst_profile, outfile_tif_LAT)    

    # shutil.rmtree(tempfolder) 
