import datetime
import os
import tempfile

import fiona
from fiona.crs import from_epsg
from shapely.geometry import mapping

VALID_LEVELS = ["LAT", "MSL"]


def tide_values_from_dfs0(mikepath, meta, dfsfilepath, level):
    """Read and extract values from dfs0 file using DHI.Generic.MikeZero.DFS.

    Parameters
    ----------
    mikepath : str
        Path to MIKE installation directory.
    meta : dictionary
        Metadata dictionary created by read_meta().
    dfsfilepath : str
        Path to the dfs file created by make_dfs0().
    level : str
        Click option LAT or MSL.

    Returns
    -------
    tide_values : list
        List of tide values for image acquisiton date and time.

    Raises
    ------
    ValueError
        If an invalid level type was provided.
    ValueError
        If DHI.Generic could not be imported or is not found in the sdkpath folder.
    ValueError
        If no tide values could be generated.

    """
    if level not in VALID_LEVELS:
        raise ValueError(f"Level should be one of {VALID_LEVELS}, not {level}.")

    import clr

    clr.AddReference("System")
    import System

    generic_mike_zero_path = list(
        mikepath.glob("**/Mike SDK/**/*DHI.Generic.MikeZero.DFS.dll")
    )[0]
    try:
        clr.AddReference(str(generic_mike_zero_path))
        import DHI.Generic.MikeZero.DFS

    except (ImportError, System.IO.FileNotFoundException) as exception:
        msg = f'DHI.Generic not found. Is the path to the mike installation directory correct: "{mikepath}"?'
        raise ValueError(msg) from exception

    dfs_img_datetime = datetime.datetime.strptime(
        meta["sensing_time"], "%Y-%m-%dT%H:%M:%S"
    )

    dfsfile = DHI.Generic.MikeZero.DFS.DfsFileFactory.DfsGenericOpen(dfsfilepath)
    tide_values = []

    # read timestep in seconds, convert to minutes
    timestep = int(dfsfile.FileInfo.TimeAxis.TimeStep / 60)
    sdt = dfsfile.FileInfo.TimeAxis.StartDateTime
    dfs_start_datetime = datetime.datetime(
        *(getattr(sdt, n) for n in ["Year", "Month", "Day", "Hour", "Minute", "Second"])
    )

    diff = dfs_img_datetime - dfs_start_datetime
    img_timestep = int(((diff.days * 24 * 60) + (diff.seconds / 60)) / timestep)

    for i in range(len(dfsfile.ItemInfo)):
        min_value = float(dfsfile.ItemInfo[i].MinValue)
        acq_value = dfsfile.ReadItemTimeStep(i + 1, img_timestep).Data[
            0
        ]  # Value c.f. MSL

        if level == "LAT":
            lat_value = acq_value - min_value  # Value above LAT
            tide_values.append(lat_value)
        elif level == "MSL":
            tide_values.append(acq_value)
        else:
            raise ValueError("Invalid level.")

    dfsfile.Dispose()

    if not tide_values:
        raise ValueError("No tide values generated, recheck AOI")

    return tide_values


def write_tide_values(tide_values, plist, level):
    """Write generated points and tide values to a new shapefile.

    Parameters
    ----------
    tide_values : list
        List of tide values generated by tide_values_from_dfs0().
    plist : list
        List of shapely points generated by create_pts().
    level : str
        Click option LAT or MSL.

    """
    pts_schema = {
        "geometry": "Point",
        "properties": {"p_ID": "int", str(level): "float"},
    }

    mem_file = fiona.MemoryFile()
    ms = mem_file.open(crs=from_epsg(4326), driver="ESRI Shapefile", schema=pts_schema,)

    for pid, (p, tv) in enumerate(zip(plist, tide_values)):
        prop = {"p_ID": int(pid + 1), str(level): float(tv)}
        ms.write({"geometry": mapping(p), "properties": prop})

    return ms


def main(infile, date, mikepath, outfile, **kwargs):
    dirpath, filepath = os.path.split(infile)
    with tempfile.TemporaryDirectory(dir=dirpath) as tempdir:
        write_tide_values(infile, date, mikepath, outfile, tempdir, **kwargs)
